Typescript provides extra types on top of JavaScript.

These types are checked before runtime which makes for a better dev environment.

The types added are the following:

+---------+-----------------+--------------------------------------------------------------------------+
|  number |   1, 5.3, -10   |          All numbers, no differentiation between ints and floats         |
+---------+-----------------+--------------------------------------------------------------------------+
|  string | "Hi",'Hi', `Hi` |                              All text values                             |
+---------+-----------------+--------------------------------------------------------------------------+
| boolean |   true, false   |                  Just these two, no truthy/falsy values                  |
+---------+-----------------+--------------------------------------------------------------------------+
|  object |     {age:30}    |        Any JS Obj, more specific types (types of obj) is possible        |
+---------+-----------------+--------------------------------------------------------------------------+
|  Array  |     [1,2,3]     | Any JS arr, type can be flexible or strict (regarding the element types) |
+---------+-----------------+--------------------------------------------------------------------------+
|  Tuple  |      [1,2]      |     Added by TS; Fixed-lengths array (.push can still mutate BAD!!!)     |
+---------+-----------------+--------------------------------------------------------------------------+
|   Enum  |  enum{NEW, OLD} |     Added by TS; Automatically enumerated global constant identifiers    |
+---------+-----------------+--------------------------------------------------------------------------+

---------------------------------------------------------------------------------------------------------

Union types

Union types is a way to set multiple types to a single variable/arg
Consider this example:

+---------------------------------------------------------------+
| const combine = (a: number | string, b: number | string) => { |
|   let res;                                                    |
|   if (typeof a === "number" && typeof b === "number") {       |
|     res = a + b;                                              |
|   } else {                                                    |
|     res = a.toString() + b.toString();                        |
|   }                                                           |
|   return res;                                                 |
| };                                                            |
+---------------------------------------------------------------+

Here we are setting arguments a and b to either a number OR (as indicated by |) number.

---------------------------------------------------------------------------------------------------------

Literal types

If we want to add a specific value as a type, we can quite easily do so;

+---------------------------------------------+
| const combine = (                           |
|   a: number | string,                       |
|   b: number | string,                       |
|   resultConversion: "as-number" | "as-text" |
| ){                                          |
|//do function                                |
|}                                            |
+---------------------------------------------+

Here we make sure that the argument "resultConversion" is always either "as-number" OR "as-text".

---------------------------------------------------------------------------------------------------------

Type aliases // Custom types

We can also create custom types/aliases, this is useful for creating smaller-reusable snippets.

Consider following example;

+------------------------------------------------------+
| type Combinable = number | string;                   |
| type ConversionDescriptor = "as-number" | "as-text"; |
|                                                      |
| const combine = (                                    |
| a: Combinable,                                       |
| b: Combinable,                                       |
| resultConversion: ConversionDescriptor               |
| ){                                                   |
| //function body                                      |
| }                                                    |
+------------------------------------------------------+

Instead of doing a: string | number and the same for B, we can create a custom type and use it for both.
Same is true for resultConversion, that way we have a centralized place for our types.

---------------------------------------------------------------------------------------------------------

Classes

We can define special properties in classes that will get checked during development. 

+------------------------------------------------------------------------------------------------------+
| class Department {                                                                                   |
|   private employees: string[] = [];                                                                  |
|   constructor(private readonly id: string, private name: string) {                                   |
|   }                                                                                                  |
|   describe() {                                                                                       |
|     console.log(                                                                                     |
|       `This is the ${this.name.toLocaleLowerCase()} department with id of: ${this.id.toUpperCase()}` |
|     );                                                                                               |
|     return this;                                                                                     |
|   }                                                                                                  |
|   addEmployee(employee: string) {                                                                    |
|     this.employees.push(employee);                                                                   |
|   }                                                                                                  |
|   printEmployeeInfo() {                                                                              |
|     console.log(this.employees.length);                                                              |
|     console.log(this.employees);                                                                     |
|   }                                                                                                  |
| }                                                                                                    |
+------------------------------------------------------------------------------------------------------+
Firstly, we can define class properties like so;

private employees: string[] = []

Lets pick this apart.

private means that that property cannot be accessed outside of the class. Meaning you cannot directly mutate it with "this.employees = "bla""
It is important to note that private properties are only accessible through the inside the class where they are defined. It does not give access to classes that extend that class, if you want the behavior or private, but give access to extensions, then you can switch private for "protected". 

+------------------------------------------------------------------+
| constructor(private readonly id: string, private name: string) { |
|   }                                                              |
+------------------------------------------------------------------+

in this seemingly weird constructor, we are using TypeScript short syntax for initializing our class.
The above example would transpile down to:

+------------------------------+
| constructor(id, name) {      |
|         this.id = id;        |
|         this.name = name;    |
|         this.employees = []; |
|     }                        |
+------------------------------+

Not only is it a shorter (albeit weird) syntax, it will also make sure that id is not mutable anywhere, and the readonly property will make sure it cannot be changed after initialization.
---------------------------------------------------------------------------------------------------------

Abstract class features.

We can also set abstract class features for when you want each iteration of a class to have a certain method or property, but you know each iteration of the class needs to implement it slightly different, but still force them to have it. 


+----------------------------------------------+
| abstract class Department {                  |
|   abstract describe(this: Department): void; |
+----------------------------------------------+

This forces the next iteration of the class to have a describe method, specifically with return void.
Another note: When we set the return type of void, we are telling TS that this return value should not be used anywhere.

---------------------------------------------------------------------------------------------------------

An interface is more or less a blueprint for how you want to structure your class.

+--------------------------------+
| interface Greetable {          |
|   readonly name: string;       |
|   greet(phrase: string): void; |
| }                              |
+--------------------------------+

+-------------------------------------+
| class Person implements Greetable { |
|   name: string;                     |
|   constructor(n: string) {          |
|     this.name = n;                  |
|   }                                 |
|                                     |
|   greet(phrase: string) {           |
|     console.log(phrase);            |
|   }                                 |
| }                                   |
+-------------------------------------+

In this example here we are saying that the class as we're implementing it should have a name and a greet method. You can also set the optional readonly property on the interface, forcing the class to implement a readonly property on the name property. 

+-------------------------------------+
| interface Named {                   |
|   name: string;                     |
| }                                   |
|                                     |
| interface Greetable extends Named { |
|   greet(phrase: string): void;      |
| }                                   |
+-------------------------------------+

Similar to classes, interfaces can also extend other interfaces. 


Optional properties and methods work the same as optional chaining. We can for example say:

+-------------------+
| interface Named { |
|   name?: string;  |
| }                 |
+-------------------+

Here we are saying that the name property may or may not exist, we wont get an error if we leave it out,  but we will still get an error if we try to set a number to name.

----------------------


Typeguards is a concept that lets us stay flexible but still get the advantages of typescript.


+-------------------------------------------+
| type Combinable = string | number         |
|                                           |
| const add= (a:Combinable,b:Combinable)=>{ |
|     return a+b                            |
| }                                         |
+-------------------------------------------+

This will always error out because "Operator "+" cannot be assigned to types "Combinable".

We can work around this with a refactor:

+---------------------------------------------------------+
| const add= (a:Combinable,b:Combinable)=>{               |
|     if(typeof a === "string" || typeof b === "string"){ |
|         return a.toString() + b.toString()              |
|     }                                                   |
|     return a + b                                        |
| }                                                       |
+---------------------------------------------------------+

Here instead of making sure that a + b is a number when returned, we can always assume that they will be, because otherwise they would have been returned in the above statement. This will give 0 errors in TypeScript

It is worth noting that if you use the instanceof operator with interfaces and typeguards, then it will not work, because interfaces are not included in runtime. Hence sometimes you may want to use more traditional types.